#!/usr/env/bin python3
# -*- coding: utf-8 -*-

"""
"""

import sys
import os
import json
import zipfile
import shutil
import tempfile
import hashlib
from collections import deque
from pathlib import Path
from io import BytesIO

import requests
from PIL import Image
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QPushButton,
    QVBoxLayout, QHBoxLayout, QGridLayout, QScrollArea,
    QMessageBox, QProgressBar, QTextEdit
)
from PySide6.QtGui import (
    QPixmap, QIcon, QColor, QPalette, QPainter, QRadialGradient, QPaintEvent, QPen, QBrush
)
from PySide6.QtCore import Qt, QThread, Signal, QUrl, QEvent, QTimer, QPropertyAnimation, QDateTime, QPoint, QRect
from PySide6.QtGui import QDesktopServices
from PySide6.QtMultimedia import QSoundEffect

# ----------------------------------------------------------------------
# PATHS
# ----------------------------------------------------------------------
DOWNLOADS_DIR = Path.home() / "Downloads"
SOUNDS_DIR = DOWNLOADS_DIR / "gallery_port_sounds"
SOUNDS_DIR.mkdir(exist_ok=True)

CLICK_FILE = SOUNDS_DIR / "roblox-click.wav"
CLICK_URL = "https://raw.githubusercontent.com/a6wwp/gallery-/main/roblox-click-sound.wav"

FIREFLIES_FILE = SOUNDS_DIR / "fireflies-ankle.wav"
FIREFLIES_URL = "https://raw.githubusercontent.com/a6wwp/gallery-/main/SpotiDownloader.com%20-%20fireflies%20-%20ankle.wav"

A6_IMAGE_FILE = SOUNDS_DIR / "A6.png"
A6_IMAGE_URL = "https://raw.githubusercontent.com/a6wwp/gallery-/main/A6.png"

SKIN_PACK_DIR = Path(os.getenv("APPDATA")) / "Minecraft Bedrock" / "premium_cache" / "skin_packs"
SKIN_PACK_DIR.mkdir(parents=True, exist_ok=True)
STATE_FILE = SKIN_PACK_DIR / ".skinpack_manager_state.json"
BACKUP_DIR = SKIN_PACK_DIR / "_backups"
BACKUP_DIR.mkdir(exist_ok=True)

STORE_URL = "https://raw.githubusercontent.com/a6wwp/gallery-/main/store.json"

# ----------------------------------------------------------------------
# FUNCTIONS
# ----------------------------------------------------------------------
def load_state():
    state = {"known": []}
    if STATE_FILE.exists():
        try:
            state = json.loads(STATE_FILE.read_text(encoding='utf-8'))
        except:
            state = {"known": []}
    if not isinstance(state.get("known"), list):
        state["known"] = list(state.get("known", {}).values())
    return state

def save_state(state):
    STATE_FILE.write_text(json.dumps(state, indent=2), encoding='utf-8')

def find_manifest(folder):
    for root, _, files in os.walk(folder):
        if "manifest.json" in files:
            return Path(root) / "manifest.json"
    return None

def read_manifest(path):
    data = json.loads(path.read_text(encoding='utf-8'))
    return data["header"]["uuid"], data["header"].get("version", [0, 0, 0])

def color_from_name(name):
    hash_obj = hashlib.md5(name.encode())
    hue = int(hash_obj.hexdigest()[:6], 16) % 360
    return QColor.fromHsl(hue, 200, 150)

def ensure_sound_file(file_path, url, description):
    if not file_path.exists():
        try:
            print(f"Downloading {description}...")
            r = requests.get(url, timeout=15)
            r.raise_for_status()
            file_path.write_bytes(r.content)
            print(f"Saved to {file_path}")
            return True
        except Exception as e:
            print(f"Failed to download {description}: {e}")
            return False
    return True

def ensure_image_file():
    if not A6_IMAGE_FILE.exists():
        try:
            print("Downloading A6 image...")
            r = requests.get(A6_IMAGE_URL, timeout=15)
            r.raise_for_status()
            A6_IMAGE_FILE.write_bytes(r.content)
            print(f"Saved to {A6_IMAGE_FILE}")
            return True
        except Exception as e:
            print(f"Failed to download A6 image: {e}")
            return False
    return True

# ----------------------------------------------------------------------
# WORKERS
# ----------------------------------------------------------------------
class StoreLoader(QThread):
    finished = Signal(list)
    error = Signal(str)
    def __init__(self, url=STORE_URL):
        super().__init__()
        self.url = url

    def run(self):
        try:
            # Aggiungi un cache buster (timestamp) per evitare la cache di GitHub
            cache_buster = f"?_={QDateTime.currentMSecsSinceEpoch()}"
            r = requests.get(self.url + cache_buster, timeout=15)
            r.raise_for_status()
            packs = r.json()["packs"]
            self.finished.emit(packs)
        except Exception as e:
            self.error.emit(str(e))

class DownloadWorker(QThread):
    progress = Signal(int)
    log = Signal(str)
    finished = Signal(Path)
    error = Signal(str)
    def __init__(self, url): super().__init__(); self.url = url
    def run(self):
        try:
            self.log.emit("Starting download...")
            tmp_dir = Path(tempfile.gettempdir()) / "mcbe_skin_downloads"
            tmp_dir.mkdir(exist_ok=True)
            zip_path = tmp_dir / "pack.zip"
            r = requests.get(self.url, stream=True, timeout=30)
            r.raise_for_status()
            total = int(r.headers.get("Content-Length", 0))
            done = 0
            with open(zip_path, "wb") as f:
                for chunk in r.iter_content(8192):
                    if not chunk: continue
                    f.write(chunk)
                    done += len(chunk)
                    if total: self.progress.emit(int(done / total * 100))
            self.progress.emit(100)
            self.log.emit("Download completed")
            self.finished.emit(zip_path)
        except Exception as e: self.error.emit(str(e))

class ThumbnailLoader(QThread):
    finished = Signal(QPixmap)
    error = Signal()
    def __init__(self, url): super().__init__(); self.url = url
    def run(self):
        try:
            r = requests.get(self.url, timeout=10)
            img = Image.open(BytesIO(r.content))
            img.thumbnail((200, 200))
            buf = BytesIO()
            img.save(buf, "PNG")
            pix = QPixmap()
            pix.loadFromData(buf.getvalue())
            self.finished.emit(pix)
        except: self.error.emit()

# ----------------------------------------------------------------------
# OVERLAY WIDGET PER IL TRAIL
# ----------------------------------------------------------------------
class TrailOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.setStyleSheet("background: transparent;")
        self.trail_positions = deque(maxlen=30)
        self.timer = QTimer()
        self.timer.timeout.connect(self.update)
        self.timer.start(33)

    def add_position(self, pos):
        now = QDateTime.currentMSecsSinceEpoch()
        self.trail_positions.append((pos, now))

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        now = QDateTime.currentMSecsSinceEpoch()
        for pos, timestamp in self.trail_positions:
            age = (now - timestamp) / 1000.0
            if age > 0.8:
                continue
            opacity = max(0, 1.0 - age / 0.8)
            size = 40
            gradient = QRadialGradient(size/2, size/2, size/2)
            gradient.setColorAt(0, QColor(255, 255, 255, int(220 * opacity)))
            gradient.setColorAt(0.7, QColor(255, 255, 255, int(100 * opacity)))
            gradient.setColorAt(1, QColor(255, 255, 255, 0))
            painter.setBrush(gradient)
            painter.setPen(Qt.NoPen)
            painter.drawEllipse(pos.x() - size//2, pos.y() - size//2, size, size)

# ----------------------------------------------------------------------
# SIMPLE SMILEY FACE WIDGET (full window)
# ----------------------------------------------------------------------
class SimpleSmileyFace(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.setStyleSheet("background: transparent;")
        self.resize(parent.size())
        self.move(0, 0)

        self.face_x = 150
        self.face_y = 150
        self.dx = 2
        self.dy = 1.5
        self.radius = 50

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_position)
        self.timer.start(20)

    def update_position(self):
        parent = self.parent()
        if not parent: return
        w = parent.width()
        h = parent.height()

        self.face_x += self.dx
        self.face_y += self.dy

        if self.face_x - self.radius < 0:
            self.face_x = self.radius
            self.dx = -self.dx
        elif self.face_x + self.radius > w:
            self.face_x = w - self.radius
            self.dx = -self.dx

        if self.face_y - self.radius < 0:
            self.face_y = self.radius
            self.dy = -self.dy
        elif self.face_y + self.radius > h:
            self.face_y = h - self.radius
            self.dy = -self.dy

        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        painter.setBrush(QColor(255, 255, 0))
        painter.setPen(Qt.NoPen)
        painter.drawEllipse(QPoint(self.face_x, self.face_y), self.radius, self.radius)

        painter.setBrush(Qt.black)
        painter.drawEllipse(QPoint(self.face_x - 20, self.face_y - 15), 8, 8)
        painter.drawEllipse(QPoint(self.face_x + 20, self.face_y - 15), 8, 8)

        pen = QPen(Qt.black, 3)
        painter.setPen(pen)
        painter.setBrush(Qt.NoBrush)
        smile_rect = QRect(self.face_x - 30, self.face_y - 10, 60, 40)
        painter.drawArc(smile_rect, 0 * 16, -180 * 16)

# ----------------------------------------------------------------------
# STORE CARD WIDGET (COMPACT – NO BADGE, NO EMPTY SPACES)
# ----------------------------------------------------------------------
class StoreCard(QWidget):
    def __init__(self, pack, state, install_cb, uninstall_cb):
        super().__init__()
        self.pack = pack
        self.install_cb = install_cb
        self.uninstall_cb = uninstall_cb
        self.thumb = None

        self.setFixedWidth(220)
        self.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                border: 1px solid #3a3a3a;
                border-radius: 12px;
                padding: 4px;
                margin: 0px;
            }
            QWidget:hover {
                border: 1px solid #6a6a6a;
                background-color: #252525;
            }
        """)

        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignTop)
        layout.setSpacing(4)
        layout.setContentsMargins(0, 0, 0, 0)

        # Thumbnail (solo se l'URL è presente)
        thumb_url = pack.get("thumbnail")
        if thumb_url:
            self.thumb = QLabel("Loading...")
            self.thumb.setFixedSize(200, 200)
            self.thumb.setAlignment(Qt.AlignCenter)
            self.thumb.setStyleSheet("border: none; background-color: #2a2a2a; border-radius: 8px;")
            layout.addWidget(self.thumb)
            self.load_thumb(thumb_url)

        # Nome del pack (sempre presente)
        is_installed = any(info.get("store_name") == pack.get("name") for info in state.get("known", []))
        name_color = color_from_name(pack.get("name", "Unnamed"))
        self.name_label = QLabel(pack.get("name", "Unnamed Pack"))
        self.name_label.setAlignment(Qt.AlignCenter)
        self.name_label.setWordWrap(True)
        self.name_label.setStyleSheet(f"color: {name_color.name()}; font-weight: bold; font-size: 14px; border: none;")
        layout.addWidget(self.name_label)

        # Pulsanti
        btns = QHBoxLayout()
        btns.setSpacing(6)

        dl = QPushButton("⬇ Download")
        dl.setCursor(Qt.PointingHandCursor)
        dl.setStyleSheet("""
            QPushButton {
                background-color: #2a6d9c;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 6px 12px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #1e5a82; }
            QPushButton:pressed { background-color: #154a6b; }
        """)
        dl.clicked.connect(lambda: install_cb(pack))
        btns.addWidget(dl)

        # Pulsante Uninstall solo se il pack è installato
        if is_installed:
            rm = QPushButton("✖ Uninstall")
            rm.setCursor(Qt.PointingHandCursor)
            rm.setStyleSheet("""
                QPushButton {
                    background-color: #8b3a3a;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    padding: 6px 12px;
                    font-weight: bold;
                }
                QPushButton:hover { background-color: #6e2e2e; }
                QPushButton:pressed { background-color: #562424; }
            """)
            rm.clicked.connect(lambda: uninstall_cb(pack))
            btns.addWidget(rm)

        layout.addLayout(btns)

    def load_thumb(self, url):
        self.thumb_loader = ThumbnailLoader(url)
        self.thumb_loader.finished.connect(self.thumb.setPixmap)
        self.thumb_loader.error.connect(lambda: self.thumb.setText("No image"))
        self.thumb_loader.start()

# ----------------------------------------------------------------------
# MAIN APPLICATION
# ----------------------------------------------------------------------
class StoreImporter(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("gallery port")
        self.resize(1000, 700)

        self.setMouseTracking(True)
        self.setWindowOpacity(0.0)

        # Scarica e imposta l'icona A6
        if ensure_image_file():
            self.setWindowIcon(QIcon(str(A6_IMAGE_FILE)))
        else:
            self.setWindowIcon(QIcon("icon.ico"))

        # Stili
        self.setStyleSheet("""
            QMainWindow { background-color: black; }
            QWidget#centralWidget {
                background-color: #000000;
                border-radius: 20px;
                margin: 10px;
            }
            QScrollArea { 
                border: none; 
                background-color: transparent; 
            }
            QWidget#scrollAreaWidgetContents { 
                background-color: transparent; 
            }
            QProgressBar {
                border: 1px solid #1a1a1a; 
                border-radius: 6px;
                background-color: #000000; 
                height: 20px;
                text-align: center; 
                color: #aaaaaa;
            }
            QProgressBar::chunk { 
                background-color: #b30000;
                border-radius: 6px; 
            }
            QTextEdit {
                background-color: transparent;
                color: #cccccc;
                border: none;
                font-family: Consolas, monospace; 
                font-size: 11px;
            }
            QPushButton#creditsButton {
                background-color: #1a1a1a; 
                color: #cccccc;
                border: 1px solid #2a2a2a; 
                border-radius: 6px;
                padding: 4px 12px;
            }
            QPushButton#creditsButton:hover { 
                background-color: #2a2a2a; 
            }
            QStatusBar { 
                background-color: #000000; 
                color: #888888; 
                border-top: 1px solid #1a1a1a;
            }
        """)

        self.state = load_state()
        self.scan_local()

        central = QWidget()
        central.setObjectName("centralWidget")
        central.setMouseTracking(True)
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(12)

        self.face = SimpleSmileyFace(central)
        self.face.lower()

        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setStyleSheet("border: none; background: transparent;")
        self.scroll.setMouseTracking(True)
        self.grid_host = QWidget()
        self.grid_host.setObjectName("scrollAreaWidgetContents")
        self.grid_host.setMouseTracking(True)
        self.grid = QGridLayout(self.grid_host)
        self.grid.setSpacing(16)
        self.grid.setAlignment(Qt.AlignTop)
        self.scroll.setWidget(self.grid_host)
        layout.addWidget(self.scroll)

        self.progress = QProgressBar()
        self.progress.setMouseTracking(True)
        self.log = QTextEdit()
        self.log.setReadOnly(True)
        self.log.setFixedHeight(120)
        self.log.setMouseTracking(True)
        layout.addWidget(self.progress)
        layout.addWidget(self.log)

        self.credits_btn = QPushButton("Credits")
        self.credits_btn.setObjectName("creditsButton")
        self.credits_btn.setCursor(Qt.PointingHandCursor)
        self.credits_btn.setMouseTracking(True)
        self.credits_btn.clicked.connect(self.show_credits)
        self.statusBar().addPermanentWidget(self.credits_btn)
        self.statusBar().setMouseTracking(True)

        self.init_sounds()

        self.trail_overlay = TrailOverlay(central)
        self.trail_overlay.setGeometry(central.rect())
        self.trail_overlay.raise_()
        self.trail_overlay.show()

        self.installEventFilterRecursively(self)

        # Variabili per il controllo periodico dello store
        self.current_packs = []           # ultimo elenco di pacchetti visualizzati
        self.store_loader_running = False # flag per evitare richieste multiple

        # Carica inizialmente lo store
        self.load_store()

        # Timer per aggiornamento automatico ogni 60 secondi
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.check_store_updates)
        self.update_timer.start(1000)
    def showEvent(self, event):
        super().showEvent(event)
        self.fade_in()

    def fade_in(self):
        self.animation = QPropertyAnimation(self, b"windowOpacity")
        self.animation.setDuration(1200)
        self.animation.setStartValue(0.0)
        self.animation.setEndValue(1.0)
        self.animation.start()

    def installEventFilterRecursively(self, widget):
        widget.installEventFilter(self)
        widget.setMouseTracking(True)
        for child in widget.findChildren(QWidget):
            child.installEventFilter(self)
            child.setMouseTracking(True)

    def init_sounds(self):
        if ensure_sound_file(CLICK_FILE, CLICK_URL, "Roblox click"):
            self.click_sound = QSoundEffect()
            self.click_sound.setSource(QUrl.fromLocalFile(str(CLICK_FILE)))
            self.click_sound.setVolume(0.1)
        else:
            self.click_sound = None

        if ensure_sound_file(FIREFLIES_FILE, FIREFLIES_URL, "Fireflies background music"):
            self.music = QSoundEffect()
            self.music.setSource(QUrl.fromLocalFile(str(FIREFLIES_FILE)))
            self.music.setVolume(0.1)
            self.music.setLoopCount(-1)
            self.music.play()
            QTimer.singleShot(1000, self.check_music)
        else:
            self.music = None

    def check_music(self):
        if self.music and self.music.status() != QSoundEffect.Playing:
            self.music.play()
            QTimer.singleShot(1000, self.check_music)

    def play_click(self):
        if self.click_sound and self.click_sound.status() == QSoundEffect.Ready:
            self.click_sound.play()

    def eventFilter(self, obj, event):
        if event.type() == QEvent.MouseButtonPress:
            self.play_click()
        elif event.type() == QEvent.MouseMove:
            local_pos = self.centralWidget().mapFromGlobal(event.globalPos())
            self.trail_overlay.add_position(local_pos)
        elif event.type() == QEvent.Resize and obj is self.centralWidget():
            self.trail_overlay.setGeometry(self.centralWidget().rect())
            self.face.resize(self.centralWidget().size())
        return super().eventFilter(obj, event)

    def scan_local(self):
        self.state["known"] = []
        for folder in SKIN_PACK_DIR.iterdir():
            if not folder.is_dir(): continue
            manifest = find_manifest(folder)
            if not manifest: continue
            try: uuid, version = read_manifest(manifest)
            except: continue
            self.state["known"].append({
                "uuid": uuid, "version": version, "path": str(folder),
                "store_name": folder.name, "source": "local"
            })
        save_state(self.state)

    def show_credits(self):
        discord_url = "https://discord.com/invite/pXTuymwQPa"
        msg = QMessageBox(self)
        msg.setWindowTitle("Credits")
        if A6_IMAGE_FILE.exists():
            pixmap = QPixmap(str(A6_IMAGE_FILE)).scaled(64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            msg.setIconPixmap(pixmap)
        msg.setText(
            "gallery port\n\n"
            "a6wwp\n\n"
            "Background music: fireflies\n"
            "Icon: A6.png"
        )
        msg.setStyleSheet("""
            QMessageBox { background-color: #1e1e1e; color: white; }
            QPushButton { background-color: #2a6d9c; color: white; border-radius: 6px; padding: 6px 12px; }
        """)
        discord_btn = msg.addButton("Open Discord", QMessageBox.ActionRole)
        msg.addButton(QMessageBox.Close)
        msg.exec()
        if msg.clickedButton() == _btn:
            QDesktopServices.openUrl(QUrl(discord_url))

    def load_store(self):
        """Carica lo store per la prima volta (all'avvio)."""
        self.store_loader = StoreLoader()
        self.store_loader.finished.connect(self.on_store_loaded)
        self.store_loader.error.connect(lambda e: QMessageBox.critical(self, "Store error", e))
        self.store_loader.start()

    def on_store_loaded(self, packs):
        """Slot chiamato quando lo store iniziale è stato caricato."""
        self.populate_store(packs)
        self.current_packs = packs
        print(f"Store iniziale caricato: {len(packs)} pacchetti")

    def check_store_updates(self):
        """Avvia un controllo asincrono per verificare se lo store è cambiato."""
        if self.store_loader_running:
            return  # già in esecuzione
        self.store_loader_running = True
        self.update_loader = StoreLoader()
        self.update_loader.finished.connect(self.on_store_updated)
        self.update_loader.error.connect(self.on_store_update_error)
        self.update_loader.start()

    def on_store_updated(self, new_packs):
        """Confronta i nuovi pacchetti con quelli correnti e aggiorna la UI se necessario."""
        self.store_loader_running = False

        # Stampa di debug
        print(f"Store aggiornato ricevuto: {len(new_packs)} pacchetti")
        current_names = {p['name'] for p in self.current_packs}
        new_names = {p['name'] for p in new_packs}

        # Se i nomi sono diversi, c'è un'aggiunta/rimozione
        if current_names != new_names:
            print(f"Nomi cambiati: correnti={current_names}, nuovi={new_names}")
            self.populate_store(new_packs)
            self.current_packs = new_packs
            self.log.append("Store aggiornato: nuovi pacchetti rilevati.")
        else:
            # Stessi nomi: controlla se i dettagli (URL, ecc.) sono cambiati
            if new_packs != self.current_packs:
                print("Dettagli pacchetti modificati (es. URL)")
                self.populate_store(new_packs)
                self.current_packs = new_packs
                self.log.append("Store aggiornato: dettagli pacchetti modificati.")
            else:
                print("Nessun cambiamento rilevato.")

    def on_store_update_error(self, error_msg):
        """In caso di errore nel caricamento periodico, si limita a resettare il flag."""
        self.store_loader_running = False
        print(f"Errore aggiornamento store: {error_msg}")

    def populate_store(self, packs):
        """Rigenera completamente la griglia con i pacchetti forniti."""
        while self.grid.count():
            w = self.grid.takeAt(0).widget()
            if w: w.deleteLater()

        row = col = 0
        for pack in packs:
            card = StoreCard(pack, self.state, self.start_download, self.uninstall_pack)
            self.grid.addWidget(card, row, col)
            col += 1
            if col == 4: col = 0; row += 1

    def start_download(self, pack):
        self.progress.setValue(0)
        self.log.clear()
        self.worker = DownloadWorker(pack["zip_url"])
        self.worker.progress.connect(self.progress.setValue)
        self.worker.log.connect(self.log.append)
        self.worker.finished.connect(lambda tmp: self.install_pack(tmp, pack))
        self.worker.error.connect(lambda e: QMessageBox.critical(self, "Download error", e))
        self.worker.start()

    def install_pack(self, tmp_zip: Path, pack):
        self.log.append("Preparing installation...")
        try:
            temp_extract = SKIN_PACK_DIR / "__temp_install__"
            if temp_extract.exists(): shutil.rmtree(temp_extract)
            temp_extract.mkdir()
            with zipfile.ZipFile(tmp_zip, "r") as z: z.extractall(temp_extract)

            manifest_path = find_manifest(temp_extract)
            if not manifest_path: raise Exception("manifest.json not found")

            new_uuid, version = read_manifest(manifest_path)
            existing = next((info for info in self.state.get("known", []) if info.get("uuid") == new_uuid), None)
            dest_folder = SKIN_PACK_DIR / new_uuid

            if existing:
                msg = QMessageBox(self)
                msg.setWindowTitle("Existing pack")
                msg.setText(
                    "A pack with the same UUID is already installed.\n\n"
                    f"Installed: {existing.get('store_name')}\n"
                    f"UUID: {new_uuid}\n\n"
                    "What do you want to do?"
                )
                msg.setStyleSheet("""
                    QMessageBox { background-color: #1e1e1e; color: white; }
                    QPushButton { background-color: #2a2a2a; color: white; border-radius: 6px; padding: 6px 12px; }
                    QPushButton:hover { background-color: #3a3a3a; }
                """)
                replace_btn = msg.addButton("Replace", QMessageBox.AcceptRole)
                backup_btn = msg.addButton("Backup and Replace", QMessageBox.DestructiveRole)
                cancel_btn = msg.addButton("Cancel", QMessageBox.RejectRole)
                msg.exec()

                if msg.clickedButton() == cancel_btn:
                    self.log.append("Installation cancelled.")
                    shutil.rmtree(temp_extract, ignore_errors=True)
                    return

                old_path = Path(existing["path"])
                if msg.clickedButton() == backup_btn:
                    backup_name = f"{existing['store_name']}_{existing['uuid']}"
                    backup_path = BACKUP_DIR / backup_name
                    if backup_path.exists(): shutil.rmtree(backup_path, ignore_errors=True)
                    shutil.copytree(old_path, backup_path)
                    self.log.append(f"Backup created: {backup_name}")

                if old_path.exists(): shutil.rmtree(old_path, ignore_errors=True)
                self.state["known"].remove(existing)

            if dest_folder.exists(): shutil.rmtree(dest_folder, ignore_errors=True)
            shutil.move(temp_extract, dest_folder)

            self.state["known"].append({
                "uuid": new_uuid, "version": version, "path": str(dest_folder),
                "store_name": pack.get("name", new_uuid), "source": "store"
            })
            save_state(self.state)

            self.log.append("✔ Installation completed.")
            self.scan_local()
            self.load_store()
        except Exception as e:
            QMessageBox.critical(self, "Installation failed", str(e))
            self.log.append(f"Error: {e}")

    def uninstall_pack(self, pack):
        infos = [i for i in self.state.get("known", []) if i.get("store_name") == pack.get("name")]
        for info in infos:
            shutil.rmtree(info.get("path", ""), ignore_errors=True)
            self.state["known"].remove(info)
        save_state(self.state)
        self.load_store()

# ----------------------------------------------------------------------
# ENTRY POINT
# ----------------------------------------------------------------------
if __name__ == "__main__":
    import ctypes
    myappid = 'gallery.port'
    ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

    app = QApplication(sys.argv)

    palette = QPalette()
    palette.setColor(QPalette.Window, Qt.black)
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, Qt.black)
    palette.setColor(QPalette.AlternateBase, QColor(20, 20, 20))
    palette.setColor(QPalette.ToolTipBase, Qt.black)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(20, 20, 20))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Highlight, QColor(42, 109, 156))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)

    win = StoreImporter()
    win.show()
    sys.exit(app.exec())
    